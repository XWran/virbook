1. 多CPU协同工作
    - SMP
    - MPP
    - NUMA
    - NUMA-Q

2. CPU 亲和性（affinita）

    软亲和性意味着进程并不会在处理器之间频繁迁移，而硬亲和性，意味着进程需要在您指定的处理器上运行。

    简单地说，CPU 亲和性（affinity） 就是进程要在某个给定的 CPU 上尽量长时间地运行而不被迁移到其他处理器的倾向性。Linux 内核进程调度器天生就具有被称为 软 CPU 亲和性（affinity） 的特性，这意味着进程通常不会在处理器之间频繁迁移。这种状态正是我们希望的，因为进程迁移的频率小就意味着产生的负载小。

    Linux Kernel 2.0之后，实现了CPU的硬亲和性，即：程序开发人员可以显式的指定进程在哪个或者哪些物理CPU上运行。

    - Linux内核的硬亲和性

        在 Linux 内核中，所有的进程都有一个相关的数据结构，称为 task_struct。这个结构非常重要，原因有很多；其中与亲和性（affinity）相关度最高的是 cpus_allowed 位掩码。这个位掩码由 n 位组成，与系统中的 n 个逻辑处理器一一对应。 具有 4 个物理 CPU 的系统可以有 4 位。如果这些 CPU 都启用了超线程，那么这个系统就有一个 8 位的位掩码。每一位掩码对应系统中一个逻辑CPU。
        如果一个进程要使用某个 CPU，则该该进程的 task_struct 中的 cpu_allowed 属性中，对应于相应逻辑 CPU 的那一位掩码，应该置为 1， 反之，则置该位为 0， 这与网络中的网络掩码的概念比较类似。Linux 中，要想进程使用所有的逻辑 CPU，则需要将掩码的所有位均置为 1，这也是 Linux 进程的缺省状态。
        Linux 内核 API 提供了两个接口，可以让用户修改或者查看掩码，他们分别是：
        - sched_set_affinity()  修改进程掩码
        - sched_get_affinity()  查询进程掩码
        注意：sched_set_affinity()具有继承关系，即：会将cpus_allowd属性传递给子进程或者线程。

    - KVM 使用硬亲和性

        通常 Linux 内核都可以很好地对进程进行调度，在应该运行的 CPU 上运行进程（这就是说，在可用的处理器上运行并获得很好的整体性能）。内核包含了一些用来检测 CPU 之间任务负载迁移的算法，可以启用进程迁移来降低繁忙的处理器的压力。
        一般情况下，在应用程序中只需使用缺省的调度器行为（Linux 软亲和性）。然而，您可能会希望在虚拟化中，使用 Linux 的硬亲和性来提高虚拟机的性能及稳定性。
        - 虚拟机用来做大数据处理，科学计算。当利用 Linux 硬亲和性指定了相应的逻辑 CPU 组时，可以减少进程在 CPU 之间的切换，提高缓存命中率，同时减少进程切换的时间，提高虚拟机的计算性能。
        - 又或者虚拟机是用来跑客户的关键业务时
